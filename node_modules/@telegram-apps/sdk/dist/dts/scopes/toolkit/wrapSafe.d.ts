import { If, MethodName, MethodNameWithVersionedParams, MethodVersionedParams, IsNever } from '@telegram-apps/bridge';
import { Computed } from '@telegram-apps/signals';
import { AnyFn } from '../../types.js';
type HasCheckSupportMethodTuple<FnArgs extends any[]> = {
    [M in MethodNameWithVersionedParams]: [
        method: M,
        parameter: MethodVersionedParams<M>,
        shouldCheck: (...args: FnArgs) => boolean
    ];
}[MethodNameWithVersionedParams];
interface CustomSupportValidator {
    fn: () => boolean;
    error: string;
}
export type IsSupported = MethodName | CustomSupportValidator | (MethodName | CustomSupportValidator)[] | {
    any: (MethodName | CustomSupportValidator)[];
};
export type Supports<Fn extends AnyFn> = Record<string, HasCheckSupportMethodTuple<Parameters<Fn>>>;
export type SafeWrapped<Fn extends AnyFn, Supported extends boolean, SupportsSchema extends Record<string, any>> = Fn & {
    /**
     * The signal returning `true` if the function is available in the
     * current environment.
     *
     * To be more accurate, the method checks the following:
     * 1. The current environment is not TMA or server.
     * 2. The SDK package is initialized.
     * 3. If passed, the `isSupported` signal returns true.
     * 4. If passed, the `isMounted` signal returns true.
     *
     * *You should use this function when possible because it provides
     * must-have code security mechanisms and makes a developer sure that
     * he is using the package properly.*
     *
     * @returns True if the function is available in the current environment.
     * @example
     * if (showBackButton.isAvailable()) {
     *   showBackButton();
     * }
     */
    isAvailable: Computed<boolean>;
    /**
     * Calls the function only in case it is available.
     * @example
     * showBackButton.ifAvailable();
     */
    ifAvailable(...args: Parameters<Fn>): ReturnType<Fn> | undefined;
} & If<Supported, {
    /**
     * The signal returning `true` if the function is supported by
     * the current Mini Apps version including some possible additional
     * conditions.
     *
     * It is highly recommended to use this signal only in certain narrow cases
     * when only the function support check is required.
     *
     * This signal is not applying additional operations like checking if the
     * current environment is Mini Apps and the SDK is initialized.
     *
     * To check if the function is available for use, use the `isAvailable`
     * signal.
     *
     * @returns True if this function is supported.
     * @see isAvailable
     * @example
     * if (setMiniAppBottomBarColor.isSupported()) {
     *   console.log('Mini App bottom bar is supported, but the function is still probably unavailable');
     * }
     */
    isSupported: Computed<boolean>;
}, {}> & If<IsNever<SupportsSchema>, {}, {
    /**
     * A map where the key is the function-specific option name and value is a signal indicating
     * if it is supported by the current environment.
     * @example
     * if (setHeaderColor.isAvailable()) {
     *   if (setHeaderColor.supports.rgb()) {
     *     setHeaderColor('#ffaabb');
     *   } else {
     *     setHeaderColor('bg_color');
     *   }
     * }
     */
    supports: Record<keyof SupportsSchema, Computed<boolean>>;
}>;
interface Options<Fn extends AnyFn> {
    component?: string;
    isMounted?: () => boolean;
    isSupported?: IsSupported;
    supports?: Supports<Fn>;
}
export declare function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;
export declare function wrapSafe<Fn extends AnyFn, O extends Options<Fn>>(method: string, fn: Fn, options: O): SafeWrapped<Fn, O extends {
    isSupported: any;
} ? true : false, O extends {
    supports: infer S extends Record<string, any>;
} ? S : never>;
export {};
